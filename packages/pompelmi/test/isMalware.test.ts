import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Path relative to this test file â†’ adjust if monorepo layout differs.
import { isMalware } from '../src/isMalware';
import * as scanModule from '../src/scan';

// Narrow ScanReport shape for our mocks to avoid importing the full type graph
interface MockScanReport {
  verdict: 'clean' | 'malicious' | 'suspicious';
}

describe('isMalware helper', () => {
  const scanSpy = vi.spyOn(scanModule as any, 'scan');

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('returns true when scan verdict is malicious', async () => {
    scanSpy.mockResolvedValueOnce({ verdict: 'malicious' } as MockScanReport);
    const result = await isMalware(Buffer.from('EICAR test string'));
    expect(result).toBe(true);
    expect(scanSpy).toHaveBeenCalledOnce();
  });

  it('returns false when scan verdict is clean', async () => {
    scanSpy.mockResolvedValueOnce({ verdict: 'clean' } as MockScanReport);
    const result = await isMalware(Buffer.from('hello world'));
    expect(result).toBe(false);
  });

  it('returns false when scan verdict is suspicious (current default policy)', async () => {
    scanSpy.mockResolvedValueOnce({ verdict: 'suspicious' } as MockScanReport);
    const result = await isMalware(Buffer.from('edge case'));
    expect(result).toBe(false);
  });
});
